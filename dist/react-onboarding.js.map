{"version":3,"file":"react-onboarding.js","sources":["../src/core/services/core.service.ts","../src/core/constants/index.ts","../src/core/index.core.ts","../src/components/onboarding/onboarding.component.tsx","../src/core/utils/snake-case.util.ts","../src/components/step/step.component.tsx","../src/components/field/field.component.tsx","../src/components/end/end.component.tsx"],"sourcesContent":["export type Tree = {\n  [x: string]: string;\n};\n\ninterface IOnboardingService {\n  tree: object;\n  setStep(step: string): void;\n  setField(field: string, step: string): void;\n  setFieldValue(field: string, step: string, value: string): void;\n  getFieldValue(field: string, step: string): string;\n}\n\nfunction OnboardingService(): IOnboardingService {\n  const tree = {};\n  function setStep(step) {\n    if (tree[step]) return;\n    tree[step] = {};\n  }\n  function setField(field, step) {\n    if (typeof tree[step] === 'undefined') {\n      setStep(step);\n    }\n    // Check if this field is already declared\n    if (tree[step][field]) return;\n    tree[step][field] = '';\n  }\n  function setFieldValue(field, step, value) {\n    if (typeof tree[step] === 'undefined' || typeof tree[step][field] === 'undefined') return;\n    tree[step][field] = value;\n  }\n  function getFieldValue(field, step) {\n    if (typeof tree[step] === 'undefined' || typeof tree[step][field] === 'undefined') return '';\n    return tree[step][field];\n  }\n  return {\n    tree,\n    setStep,\n    setField,\n    setFieldValue,\n    getFieldValue,\n  };\n}\n\nconst onboardingService = OnboardingService();\nexport { onboardingService as OnboardingService };\n","export const STEP_TYPE_KEY: string = 'STEP';\nexport const FIELD_TYPE_KEY: string = 'FIELD';\nexport const END_TYPE_KEY: string = 'END';\n","import { Children } from 'react';\nimport { STEP_TYPE_KEY, FIELD_TYPE_KEY } from './constants';\n\nexport type StepEnhancements = {\n  nextStep: Function;\n  prevStep: Function;\n  validStep?: boolean;\n};\n\nexport type EnhancedStep = JSX.Element & {\n  nextStep: Function;\n  prevStep: Function;\n};\n\nexport type FieldEnhancements = {\n  step: string;\n  setProcessed: Function;\n  setValidStep: Function;\n};\n\nexport type EnhancedField = JSX.Element & {\n  step: string;\n  setProcessed: Function;\n  setValidStep: Function;\n};\n\n/**\n * PUBLIC\n * This function calculates the number of steps that\n * are present in an Array of React Components.\n * This will only count the first level of steps due to\n * there's no reason for a step to be within a step.\n * @param {Array} tree\n */\nexport function calculateNumberOfSteps(tree: JSX.Element[] | JSX.Element): number {\n  return Children.map(tree, leaf => {\n    if (leaf.type.__type === STEP_TYPE_KEY) return leaf;\n    return;\n  }).length;\n}\n/**\n * PUBLIC\n * This function enhaces a step (React Object) with\n * some required internal data to make the system work\n * as expected.\n * @param {Object} step\n * @param {Object} enhancements\n */\nexport function enhanceStep(step: JSX.Element, enhancements: StepEnhancements): JSX.Element | EnhancedStep {\n  const type = step.type.__type;\n  if (type !== STEP_TYPE_KEY) return step;\n  return {\n    ...step,\n    key: step.props.name,\n    props: {\n      ...step.props,\n      __enhancements: enhancements,\n    },\n  };\n}\n/**\n * PUBLIC\n * This function enhaces a field (React Object) with\n * some required internal data to make the system work\n * as expected.\n * @param {Object} step\n * @param {Object} enhancements\n */\nexport function enhanceField(field: JSX.Element, enhancements: FieldEnhancements): JSX.Element | EnhancedField {\n  const type = field.type.__type;\n  if (type !== FIELD_TYPE_KEY) return field;\n  return {\n    ...field,\n    key: field.props.name,\n    props: {\n      ...field.props,\n      __enhancements: enhancements,\n    },\n  };\n}\n","import * as React from 'react';\n\nimport { OnboardingService } from '../../core/services/core.service';\n\nimport { enhanceStep, calculateNumberOfSteps } from '../../core/index.core';\nimport { STEP_TYPE_KEY, END_TYPE_KEY } from '../../core/constants';\n\nconst { Provider, Consumer } = React.createContext({});\n\ntype Props = {\n  initialStep: number;\n  finished: boolean;\n  children: JSX.Element[] | JSX.Element;\n};\ntype State = {\n  initialStep: number;\n  currentStep: number;\n};\n\nclass Onboarding extends React.Component<Props, State> {\n  numberOfSteps: number;\n  constructor(props: Readonly<Props>) {\n    super(props);\n    this.state = {\n      initialStep: props.initialStep || 0,\n      currentStep: props.initialStep || 0,\n    };\n    this.numberOfSteps = calculateNumberOfSteps(props.children);\n  }\n\n  nextStep = (): void => {\n    const { currentStep } = this.state;\n    // Check if we want to move beyond the last step\n    if (currentStep + 1 >= this.numberOfSteps) return;\n    this.setState(prevState => ({\n      ...prevState,\n      currentStep: prevState.currentStep + 1,\n    }));\n  };\n\n  prevStep = (): void => {\n    const { currentStep } = this.state;\n    // Check if we want to move beyond the first step\n    if (currentStep - 1 < 0) return;\n    this.setState(prevState => ({\n      ...prevState,\n      currentStep: prevState.currentStep - 1,\n    }));\n  };\n\n  shouldComponentUpdate(nextProps: Props, nextState: State) {\n    const { currentStep } = this.state;\n    const { finished } = this.props;\n    return currentStep !== nextState.currentStep || finished !== nextProps.finished;\n  }\n\n  onboardingRenderer = (): JSX.Element | JSX.Element[] => {\n    const { children, finished } = this.props;\n    const { currentStep } = this.state;\n    let encounteredStep = 0;\n    let stepFound = false;\n    const elements = React.Children.map(children, (child: JSX.Element, i: number) => {\n      // Somehow, there could be childs that are null\n      // Maybe related to {onboardingComplete && (<component></component>)} expressions\n      // We have to skip those null child since we don't want to render them\n      if (!child) return;\n      const type = child.type.__type;\n      if (!type) return child;\n      if (!finished && type === END_TYPE_KEY) return;\n      if (!finished && type !== END_TYPE_KEY && type !== STEP_TYPE_KEY) return child;\n      if (!finished && type === STEP_TYPE_KEY) {\n        if (encounteredStep === currentStep && !stepFound) {\n          stepFound = true;\n          return enhanceStep(child, {\n            nextStep: this.nextStep,\n            prevStep: this.prevStep,\n          });\n        }\n        encounteredStep = encounteredStep + 1;\n        return;\n      }\n      if (finished && type !== STEP_TYPE_KEY) return child;\n    });\n    return elements;\n  };\n\n  render() {\n    const { currentStep } = this.state;\n    return (\n      <Provider\n        value={{\n          numberOfSteps: this.numberOfSteps,\n          currentStep: currentStep + 1,\n          onboarding: OnboardingService.tree,\n          prevStep: this.prevStep,\n          nextStep: this.nextStep,\n        }}\n      >\n        {this.onboardingRenderer()}\n      </Provider>\n    );\n  }\n}\n\nexport { Onboarding, Consumer as Info };\n","export function snakeCase(value: string): string {\n  return value.replace(/-/gi, '_');\n}\n","import * as React from 'react';\nimport { enhanceField, StepEnhancements } from '../../core/index.core';\nimport { OnboardingService } from '../../core/services/core.service';\nimport { snakeCase } from '../../core/utils';\nimport { STEP_TYPE_KEY } from '../../core/constants';\n\ntype Props = {\n  name: string;\n  conversational: boolean;\n  children: (props: StepEnhancements) => JSX.Element;\n  __enhancements: StepEnhancements;\n};\ntype State = {\n  validStep: boolean;\n  processed: boolean;\n};\n\nclass Step extends React.Component<Props, State> {\n  step: string;\n  constructor(props: Readonly<Props>) {\n    super(props);\n    const snaked_name = snakeCase(props.name);\n    OnboardingService.setStep(snaked_name);\n    /**\n     * NOTE\n     * There's a special step type: the conversational step\n     * This field is ment to be a source of feedback to the user\n     * meaning that, it won't have any fields or validations so,\n     * this step should be processed and valid by default.\n     */\n    const conversational: boolean = props.conversational;\n    this.state = { validStep: false, processed: conversational ? true : false };\n  }\n\n  setValidStep = (isValid: boolean): void => this.setState({ validStep: isValid });\n  setProcessed = (processed: boolean): void => this.setState({ processed });\n\n  componentDidMount() {\n    /**\n     * NOTE\n     * To be able to have optional steps\n     * we have to check if some of the children have validations attached\n     * this way. A step, by default has an unprocessed state (!processed)\n     * meaning that the user have to provide some input. By checking if\n     * the child have validations we could declare this step as processed beforehand\n     * so we can click next without having to provide any input\n     */\n    const {\n      props: { children: stepContents },\n    } = this.props.children({ nextStep: () => {}, prevStep: () => {}, validStep: true });\n    const someHaveValidations = stepContents.some((child: JSX.Element) => child.props.validations);\n    if (someHaveValidations) return;\n    this.setState({ validStep: true, processed: true });\n  }\n\n  stepRenderer = (): JSX.Element => {\n    const {\n      children,\n      name: stepName,\n      __enhancements: { nextStep, prevStep },\n    } = this.props;\n    const { validStep, processed } = this.state;\n    /**\n     * NOTE\n     * If the status of this form is invalid (!validStep), the\n     * next step function is setted to an empty function that\n     * returns null to prevent the user to move to next step\n     */\n    const stepContents = children({\n      nextStep: processed ? nextStep : () => null,\n      prevStep: prevStep ? prevStep : () => null,\n      validStep: validStep && processed ? true : false,\n    });\n    // Here we check if we have multiple childs for this step or a single one\n    if (Array.isArray(stepContents.props.children)) {\n      // Children comes in the flavor of array so we have to map over to\n      // enhance any of those who's a Field\n      return {\n        ...stepContents,\n        props: {\n          children: stepContents.props.children.map((child: JSX.Element) => {\n            return enhanceField(child, {\n              step: snakeCase(stepName),\n              setValidStep: this.setValidStep,\n              setProcessed: this.setProcessed,\n            });\n          }),\n        },\n      };\n    } else {\n      // Children comes in the flavor or an object so we don't have to\n      // map over and just enhace the children in case it's a Field\n      return {\n        ...stepContents,\n        props: {\n          children: enhanceField(stepContents.props.children, {\n            step: snakeCase(stepName),\n            setValidStep: this.setValidStep,\n            setProcessed: this.setProcessed,\n          }),\n        },\n      };\n    }\n  };\n\n  render() {\n    return this.stepRenderer();\n  }\n}\n\n// @ts-ignore\nStep.__type = STEP_TYPE_KEY;\n\nexport default Step;\n","import * as React from 'react';\nimport { OnboardingService } from '../../core/services/core.service';\nimport { snakeCase } from '../../core/utils';\nimport { FieldEnhancements } from '../../core/index.core';\nimport { FIELD_TYPE_KEY } from '../../core/constants';\n\ntype Validation = {\n  name: string;\n  on: string;\n  validator: Function;\n  errorMessage: string;\n};\n\ntype FieldHanders = {\n  value: string;\n  type: string;\n  onChange: Function;\n  onBlur: Function;\n  onFocus: Function;\n  error: string;\n  valid: boolean;\n};\n\ntype Props = {\n  __enhancements: FieldEnhancements;\n  validations: Validation[];\n  name: string;\n  type: string;\n  children: (props: FieldHanders) => JSX.Element;\n};\n\ntype State = {\n  value: string;\n  valid: boolean;\n  error: string;\n};\n\nclass Field extends React.Component<Props, State> {\n  step: string;\n  snaked_name: string;\n  constructor(props: Props) {\n    super(props);\n    // Get Step name from enhancements\n    const {\n      __enhancements: { step },\n    } = this.props;\n    // Snake case the name and set it\n    this.snaked_name = snakeCase(props.name);\n    // Set the step for further use\n    this.step = step;\n    // Set this field within the onboarding service\n    OnboardingService.setField(this.snaked_name, step);\n    this.state = {\n      value: OnboardingService.getFieldValue(this.snaked_name, step),\n      valid: true,\n      error: null,\n    };\n  }\n\n  onChange = value => {\n    // First we asume the field status is valid\n    this.setState(\n      () => ({ valid: true, error: null }),\n      () => {\n        // Set that this field had some input\n        const {\n          __enhancements: { setProcessed },\n        } = this.props;\n        // Field has to be setted anyway\n        OnboardingService.setFieldValue(this.snaked_name, this.step, value);\n        this.setState({ value: value });\n        const { validations = [] } = this.props;\n        // Check if this field has validations\n        if (validations.length !== 0) {\n          const onChangeValidations = validations.filter(validation => validation.on === 'change');\n          if (onChangeValidations) {\n            /**\n             * NOTE\n             * We would like to stop running validations of we\n             * already have a validation that has failed\n             * that's why we're using a for-loop instead of a forEach.\n             */\n            let alreadyErrored = false;\n            for (let i = 0; i < onChangeValidations.length && !alreadyErrored; i++) {\n              const {\n                __enhancements: { setValidStep },\n              } = this.props;\n              const validationOk = onChangeValidations[i].validator(value);\n              if (!validationOk) {\n                this.setState({ valid: false, error: onChangeValidations[i].errorMessage });\n                // Raise the flag so we stop running the loop\n                alreadyErrored = true;\n              }\n              setValidStep(validationOk);\n            }\n          }\n        }\n        setProcessed(true);\n      },\n    );\n  };\n\n  onFocus = () => {\n    // First we asume the field status is valid\n    this.setState(\n      () => ({ valid: true, error: null }),\n      () => {\n        const { value } = this.state;\n        const { validations = [] } = this.props;\n        // Check if this field has validations\n        if (validations.length !== 0) {\n          const onFocusValidations = validations.filter(validation => validation.on === 'focus');\n          if (onFocusValidations) {\n            /**\n             * NOTE\n             * We would like to stop running validations of we\n             * already have a validation that has failed\n             * that's why we're using a for-loop instead of a forEach.\n             */\n            let alreadyErrored = false;\n            for (let i = 0; i < onFocusValidations.length && !alreadyErrored; i++) {\n              const {\n                __enhancements: { setValidStep },\n              } = this.props;\n              const validationOk = onFocusValidations[i].validator(value);\n              if (!validationOk) {\n                this.setState({ valid: false, error: onFocusValidations[i].errorMessage });\n                // Raise the flag so we stop running the loop\n                alreadyErrored = true;\n              }\n              setValidStep(validationOk);\n            }\n          }\n        }\n      },\n    );\n  };\n\n  onBlur = () => {\n    // First we asume that field status is valid\n    this.setState(\n      () => ({ valid: true, error: null }),\n      () => {\n        const { value } = this.state;\n        const { validations = [] } = this.props;\n        // Check if this field has validations\n        if (validations.length !== 0) {\n          const onBlurValidations = validations.filter(validation => validation.on === 'blur');\n          if (onBlurValidations) {\n            /**\n             * NOTE\n             * We would like to stop running validations of we\n             * already have a validation that has failed\n             * that's why we're using a for-loop instead of a forEach.\n             */\n            let alreadyErrored = false;\n            for (let i = 0; i < onBlurValidations.length && !alreadyErrored; i++) {\n              const {\n                __enhancements: { setValidStep },\n              } = this.props;\n              const validationOk = onBlurValidations[i].validator(value);\n              if (!validationOk) {\n                this.setState({ valid: false, error: onBlurValidations[i].errorMessage });\n                // Raise the flag so we stop running the loop\n                alreadyErrored = true;\n              }\n              setValidStep(validationOk);\n            }\n          }\n        }\n      },\n    );\n  };\n\n  render() {\n    const { children, type } = this.props;\n    const { value, error, valid } = this.state;\n    return children({\n      value,\n      type,\n      onChange: this.onChange,\n      onBlur: this.onBlur,\n      onFocus: this.onFocus,\n      error: error,\n      valid,\n    });\n  }\n}\n\n// @ts-ignore\nField.__type = FIELD_TYPE_KEY;\n\nexport default Field;\n","import * as React from 'react';\n\nimport { OnboardingService, Tree } from '../../core/services/core.service';\nimport { END_TYPE_KEY } from '../../core/constants';\n\ntype Props = {\n  children: Function;\n};\ntype State = {\n  tree: Tree;\n};\n\nclass End extends React.Component<Props, State> {\n  state = {\n    tree: { ...OnboardingService.tree },\n  };\n\n  render() {\n    const children: Function = this.props.children;\n    return children(this.state.tree);\n  }\n}\n\n// @ts-ignore\nEnd.__type = END_TYPE_KEY;\n\nexport default End;\n"],"names":["onboardingService","tree","setStep","step","field","value","OnboardingService","STEP_TYPE_KEY","FIELD_TYPE_KEY","END_TYPE_KEY","enhanceField","enhancements","type","__type","Object","key","props","name","__enhancements","React","Onboarding","constructor","this","state","numberOfSteps","setState","prevState","currentStep","encounteredStep","stepFound","map","child","i","finished","nextStep","prevStep","initialStep","Children","children","leaf","length","shouldComponentUpdate","nextProps","nextState","render","Provider","onboarding","onboardingRenderer","snakeCase","replace","Step","isValid","validStep","processed","stepContents","Array","isArray","stepName","setValidStep","setProcessed","snaked_name","conversational","componentDidMount","some","validations","stepRenderer","Field","valid","error","setFieldValue","onChangeValidations","filter","validation","on","alreadyErrored","validationOk","validator","errorMessage","onFocusValidations","onBlurValidations","setField","getFieldValue","onChange","onBlur","onFocus","End"],"mappings":"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"}