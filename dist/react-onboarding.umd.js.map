{"version":3,"file":"react-onboarding.umd.js","sources":["../src/core/services/core.service.ts","../src/core/constants/index.ts","../src/components/onboarding/onboarding.component.tsx","../src/core/index.core.ts","../src/core/utils/snake-case.util.ts","../src/components/step/step.component.tsx","../src/components/field/field.component.tsx","../src/components/end/end.component.tsx"],"sourcesContent":["export type Tree = {\n  [x: string]: string;\n};\n\ninterface IOnboardingService {\n  tree: object;\n  setStep(step: string): void;\n  setField(field: string, step: string): void;\n  setFieldValue(field: string, step: string, value: string): void;\n  getFieldValue(field: string, step: string): string;\n}\n\nfunction OnboardingService(): IOnboardingService {\n  const tree = {};\n  function setStep(step) {\n    if (tree[step]) return;\n    tree[step] = {};\n  }\n  function setField(field, step) {\n    if (typeof tree[step] === 'undefined') {\n      setStep(step);\n    }\n    // Check if this field is already declared\n    if (tree[step][field]) return;\n    tree[step][field] = '';\n  }\n  function setFieldValue(field, step, value) {\n    if (typeof tree[step] === 'undefined' || typeof tree[step][field] === 'undefined') return;\n    tree[step][field] = value;\n  }\n  function getFieldValue(field, step) {\n    if (typeof tree[step] === 'undefined' || typeof tree[step][field] === 'undefined') return '';\n    return tree[step][field];\n  }\n  return {\n    tree,\n    setStep,\n    setField,\n    setFieldValue,\n    getFieldValue,\n  };\n}\n\nconst onboardingService = OnboardingService();\nexport { onboardingService as OnboardingService };\n","export const STEP_TYPE_KEY: string = 'STEP';\nexport const FIELD_TYPE_KEY: string = 'FIELD';\nexport const END_TYPE_KEY: string = 'END';\n","import * as React from 'react';\n\nimport { OnboardingService } from '../../core/services/core.service';\n\nimport { enhanceStep, calculateNumberOfSteps } from '../../core/index.core';\nimport { STEP_TYPE_KEY, END_TYPE_KEY } from '../../core/constants';\n\nconst { Provider, Consumer } = React.createContext({});\n\ntype Props = {\n  initialStep: number;\n  finished: boolean;\n  children: JSX.Element[] | JSX.Element;\n};\ntype State = {\n  initialStep: number;\n  currentStep: number;\n  finished: boolean;\n};\n\nclass Onboarding extends React.Component<Props, State> {\n  numberOfSteps: number;\n  constructor(props: Readonly<Props>) {\n    super(props);\n    this.state = {\n      initialStep: props.initialStep || 0,\n      currentStep: props.initialStep || 0,\n      finished: false,\n    };\n    this.numberOfSteps = calculateNumberOfSteps(props.children);\n  }\n\n  nextStep = (): void => {\n    const { currentStep } = this.state;\n    // Check if we want to move beyond the last step\n    if (currentStep + 1 >= this.numberOfSteps) return;\n    this.setState(prevState => ({\n      ...prevState,\n      currentStep: prevState.currentStep + 1,\n    }));\n  };\n\n  prevStep = (): void => {\n    const { currentStep } = this.state;\n    // Check if we want to move beyond the first step\n    if (currentStep - 1 < 0) return;\n    this.setState(prevState => ({\n      ...prevState,\n      currentStep: prevState.currentStep - 1,\n    }));\n  };\n\n  finishForm = (): void => {\n    this.setState({ finished: true });\n  };\n\n  shouldComponentUpdate(nextProps: Props, nextState: State) {\n    const { currentStep, finished } = this.state;\n    return currentStep !== nextState.currentStep || finished !== nextState.finished;\n  }\n\n  onboardingRenderer = (): JSX.Element | JSX.Element[] => {\n    const { children } = this.props;\n    const { currentStep, finished } = this.state;\n    let encounteredStep = 0;\n    let stepFound = false;\n    let processedSteps = [];\n    const elements = React.Children.map(children, (child: JSX.Element) => {\n      // Somehow, there could be childs that are null\n      // Maybe related to {onboardingComplete && (<component></component>)} expressions\n      // We have to skip those null child since we don't want to render them\n      if (!child) return;\n      const type = child.type.__type;\n      // Components that are not type STEP or END\n      // didn't have a TYPE_KEY so we could have ended\n      // with a end page with aditional unwanted components\n      if (!finished && !type) return child;\n      if (!finished && type === END_TYPE_KEY) return;\n      if (!finished && type !== END_TYPE_KEY && type !== STEP_TYPE_KEY) return child;\n      if (!finished && type === STEP_TYPE_KEY) {\n        // Check to avoid duplicated step identifiers\n        if (processedSteps.includes(child.props.name)) {\n          throw new Error(`You have defined a duplicated step. ${child.props.name} step has already been defined.`);\n        }\n        processedSteps = [...processedSteps, child.props.name];\n        if (encounteredStep === currentStep && !stepFound) {\n          stepFound = true;\n          return enhanceStep(child, {\n            nextStep: this.nextStep,\n            prevStep: this.prevStep,\n            finish: this.finishForm,\n          });\n        }\n        encounteredStep = encounteredStep + 1;\n        return;\n      }\n      if (finished && type !== END_TYPE_KEY) return;\n      if (finished && type === END_TYPE_KEY) return child;\n    });\n    return elements;\n  };\n\n  render() {\n    const { currentStep } = this.state;\n    return (\n      <Provider\n        value={{\n          numberOfSteps: this.numberOfSteps,\n          currentStep: currentStep + 1,\n          onboarding: OnboardingService.tree,\n          prevStep: this.prevStep,\n          nextStep: this.nextStep,\n          finish: this.finishForm,\n        }}\n      >\n        {this.onboardingRenderer()}\n      </Provider>\n    );\n  }\n}\n\nexport { Onboarding, Consumer as Info };\n","import { Children } from 'react';\nimport { STEP_TYPE_KEY, FIELD_TYPE_KEY } from './constants';\n\nexport type StepEnhancements = {\n  nextStep: Function;\n  prevStep: Function;\n  finish: Function;\n  validStep?: boolean;\n};\n\nexport type EnhancedStep = JSX.Element & {\n  nextStep: Function;\n  prevStep: Function;\n  finish: Function;\n};\n\nexport type FieldEnhancements = {\n  step: string;\n  setProcessed: Function;\n  setValidStep: Function;\n};\n\nexport type EnhancedField = JSX.Element & {\n  step: string;\n  setProcessed: Function;\n  setValidStep: Function;\n};\n\n/**\n * PUBLIC\n * This function calculates the number of steps that\n * are present in an Array of React Components.\n * This will only count the first level of steps due to\n * there's no reason for a step to be within a step.\n * @param {Array} tree\n */\nexport function calculateNumberOfSteps(tree: JSX.Element[] | JSX.Element): number {\n  return Children.map(tree, leaf => {\n    if (leaf.type.__type === STEP_TYPE_KEY) return leaf;\n    return;\n  }).length;\n}\n/**\n * PUBLIC\n * This function enhaces a step (React Object) with\n * some required internal data to make the system work\n * as expected.\n * @param {Object} step\n * @param {Object} enhancements\n */\nexport function enhanceStep(step: JSX.Element, enhancements: StepEnhancements): JSX.Element | EnhancedStep {\n  const type = step.type.__type;\n  if (type !== STEP_TYPE_KEY) return step;\n  return {\n    ...step,\n    key: step.props.name,\n    props: {\n      ...step.props,\n      __enhancements: enhancements,\n    },\n  };\n}\n/**\n * PUBLIC\n * This function enhaces a field (React Object) with\n * some required internal data to make the system work\n * as expected.\n * @param {Object} step\n * @param {Object} enhancements\n */\nexport function enhanceField(field: JSX.Element, enhancements: FieldEnhancements): JSX.Element | EnhancedField {\n  const type = field.type.__type;\n  if (type !== FIELD_TYPE_KEY) return field;\n  return {\n    ...field,\n    key: field.props.name,\n    props: {\n      ...field.props,\n      __enhancements: enhancements,\n    },\n  };\n}\n","export function snakeCase(value: string): string {\n  return value.replace(/-/gi, '_');\n}\n","import * as React from 'react';\nimport { enhanceField, StepEnhancements } from '../../core/index.core';\nimport { OnboardingService } from '../../core/services/core.service';\nimport { snakeCase } from '../../core/utils';\nimport { STEP_TYPE_KEY, FIELD_TYPE_KEY } from '../../core/constants';\n\ntype Props = {\n  name: string;\n  conversational: boolean;\n  children: (props: StepEnhancements) => JSX.Element;\n  __enhancements: StepEnhancements;\n};\ntype State = {\n  validStep: boolean;\n  processed: boolean;\n};\n\nclass Step extends React.Component<Props, State> {\n  step: string;\n  constructor(props: Readonly<Props>) {\n    super(props);\n    const snaked_name = snakeCase(props.name);\n    // Only not conversational steps are going to be setted\n    if (!props.conversational) {\n      OnboardingService.setStep(snaked_name);\n    }\n    /**\n     * NOTE\n     * There's a special step type: the conversational step\n     * This field is ment to be a source of feedback to the user\n     * meaning that, it won't have any fields or validations so,\n     * this step should be processed and valid by default.\n     */\n    const conversational: boolean = props.conversational;\n    this.state = { validStep: true, processed: conversational ? true : false };\n  }\n\n  setValidStep = (isValid: boolean): void => this.setState({ validStep: isValid });\n  setProcessed = (processed: boolean): void => this.setState({ processed });\n\n  componentDidMount() {\n    /**\n     * NOTE\n     * To be able to have optional steps\n     * we have to check if some of the children have validations attached\n     * this way. A step, by default has an unprocessed state (!processed)\n     * meaning that the user have to provide some input. By checking if\n     * the child have validations we could declare this step as processed beforehand\n     * so we can click next without having to provide any input\n     */\n    const {\n      props: { children: stepContents },\n    } = this.props.children({ nextStep: () => {}, prevStep: () => {}, finish: () => {}, validStep: true });\n    const someHaveValidations = stepContents.some((child: JSX.Element) => child.props.validations);\n    if (someHaveValidations) return;\n    this.setState({ processed: true });\n  }\n\n  stepRenderer = (): JSX.Element | JSX.Element[] => {\n    const {\n      children,\n      name: stepName,\n      __enhancements: { nextStep, prevStep, finish },\n    } = this.props;\n    const { validStep, processed } = this.state;\n    /**\n     * NOTE\n     * If the status of this form is not processed, the\n     * next step function is setted to an empty function that\n     * returns null to prevent the user to move to next step\n     */\n    const stepContents = children({\n      nextStep: processed ? nextStep : () => null,\n      prevStep: prevStep ? prevStep : () => null,\n      finish: processed ? finish : () => null,\n      validStep: validStep,\n    });\n\n    return {\n      ...stepContents,\n      props: {\n        children: React.Children.map(stepContents.props.children, (child: JSX.Element) => {\n          if (!child) return;\n          const type = child.type.__type;\n          if (type === FIELD_TYPE_KEY) {\n            return enhanceField(child, {\n              step: snakeCase(stepName),\n              setValidStep: this.setValidStep,\n              setProcessed: this.setProcessed,\n            });\n          }\n          return child;\n        }),\n      },\n    };\n  };\n\n  render() {\n    return this.stepRenderer();\n  }\n}\n\n// @ts-ignore\nStep.__type = STEP_TYPE_KEY;\n\nexport default Step;\n","import * as React from 'react';\nimport { OnboardingService } from '../../core/services/core.service';\nimport { snakeCase } from '../../core/utils';\nimport { FieldEnhancements } from '../../core/index.core';\nimport { FIELD_TYPE_KEY } from '../../core/constants';\n\ntype EnterValidation = {\n  name: string;\n  on: string;\n  validations?: string[];\n};\n\ntype Validation = {\n  name: string;\n  on: string;\n  validator: Function;\n  errorMessage: string;\n};\n\ntype FieldHanders = {\n  value: string;\n  type: string;\n  onChange: Function;\n  onBlur: Function;\n  onFocus: Function;\n  onEnter: Function;\n  error: string;\n  valid: boolean;\n};\n\ntype Props = {\n  __enhancements: FieldEnhancements;\n  validations: Validation[];\n  name: string;\n  type: string;\n  children: (props: FieldHanders) => JSX.Element;\n};\n\ntype State = {\n  value: string;\n  valid: boolean;\n  error: string;\n};\n\nfunction checkForDuplicatedEnterValidation(validations: EnterValidation[]) {\n  return validations.filter((validation: EnterValidation) => validation.on === 'enter').length > 1;\n}\n\nclass Field extends React.Component<Props, State> {\n  step: string;\n  snaked_name: string;\n  constructor(props: Props) {\n    super(props);\n    // Get Step name from enhancements\n    const {\n      validations,\n      __enhancements: { step },\n    } = this.props;\n    // Snake case the name and set it\n    this.snaked_name = snakeCase(props.name);\n    // Set the step for further use\n    this.step = step;\n    // Set this field within the onboarding service\n    OnboardingService.setField(this.snaked_name, step);\n    this.state = {\n      value: OnboardingService.getFieldValue(this.snaked_name, step),\n      valid: true,\n      error: null,\n    };\n    if (validations && validations.length !== 0) {\n      if (checkForDuplicatedEnterValidation(validations)) {\n        console.warn(\n          `You have defined various \"enter\" validations for the \"${\n            props.name\n          }\" field. Only the first occurrence will be used, the rest will be discarted`,\n        );\n      }\n    }\n  }\n\n  onChange = (value: string): Promise<any> => {\n    return new Promise(resolve => {\n      // First we asume the field status is valid\n      this.setState(\n        () => ({ valid: true, error: null }),\n        () => {\n          // Set that this field had some input\n          const {\n            __enhancements: { setProcessed },\n          } = this.props;\n          // Field has to be setted anyway\n          OnboardingService.setFieldValue(this.snaked_name, this.step, value);\n          this.setState({ value: value });\n          const { validations = [] } = this.props;\n          // Check if this field has validations\n          if (validations.length !== 0) {\n            const onChangeValidations = validations.filter(validation => validation.on === 'change');\n            if (onChangeValidations) {\n              /**\n               * NOTE\n               * We would like to stop running validations of we\n               * already have a validation that has failed\n               * that's why we're using a for-loop instead of a forEach.\n               */\n              let alreadyErrored = false;\n              for (let i = 0; i < onChangeValidations.length && !alreadyErrored; i++) {\n                const {\n                  __enhancements: { setValidStep },\n                } = this.props;\n                const validationOk = onChangeValidations[i].validator(value);\n                if (!validationOk) {\n                  this.setState({ valid: false, error: onChangeValidations[i].errorMessage });\n                  // Raise the flag so we stop running the loop\n                  alreadyErrored = true;\n                }\n                setValidStep(validationOk);\n                resolve();\n              }\n            }\n          }\n          setProcessed(true);\n          resolve();\n        },\n      );\n    });\n  };\n\n  onFocus = (): Promise<any> => {\n    return new Promise(resolve => {\n      // First we asume the field status is valid\n      this.setState(\n        () => ({ valid: true, error: null }),\n        () => {\n          const { value } = this.state;\n          const { validations = [] } = this.props;\n          // Check if this field has validations\n          if (validations.length !== 0) {\n            const onFocusValidations = validations.filter(validation => validation.on === 'focus');\n            if (onFocusValidations) {\n              /**\n               * NOTE\n               * We would like to stop running validations of we\n               * already have a validation that has failed\n               * that's why we're using a for-loop instead of a forEach.\n               */\n              let alreadyErrored = false;\n              for (let i = 0; i < onFocusValidations.length && !alreadyErrored; i++) {\n                const {\n                  __enhancements: { setValidStep },\n                } = this.props;\n                const validationOk = onFocusValidations[i].validator(value);\n                if (!validationOk) {\n                  this.setState({ valid: false, error: onFocusValidations[i].errorMessage });\n                  // Raise the flag so we stop running the loop\n                  alreadyErrored = true;\n                }\n                setValidStep(validationOk);\n                resolve();\n              }\n            }\n          }\n          resolve();\n        },\n      );\n    });\n  };\n\n  onBlur = (): Promise<any> => {\n    return new Promise(resolve => {\n      // First we asume that field status is valid\n      this.setState(\n        () => ({ valid: true, error: null }),\n        () => {\n          const { value } = this.state;\n          const { validations = [] } = this.props;\n          // Check if this field has validations\n          if (validations.length !== 0) {\n            const onBlurValidations = validations.filter(validation => validation.on === 'blur');\n            if (onBlurValidations) {\n              /**\n               * NOTE\n               * We would like to stop running validations of we\n               * already have a validation that has failed\n               * that's why we're using a for-loop instead of a forEach.\n               */\n              let alreadyErrored = false;\n              for (let i = 0; i < onBlurValidations.length && !alreadyErrored; i++) {\n                const {\n                  __enhancements: { setValidStep },\n                } = this.props;\n                const validationOk = onBlurValidations[i].validator(value);\n                if (!validationOk) {\n                  this.setState({ valid: false, error: onBlurValidations[i].errorMessage });\n                  // Raise the flag so we stop running the loop\n                  alreadyErrored = true;\n                }\n                setValidStep(validationOk);\n                resolve();\n              }\n            }\n          }\n          resolve();\n        },\n      );\n    });\n  };\n\n  onEnter = (enterCallback: Function): void => {\n    const { validations = [] } = this.props;\n    if (validations.length !== 0) {\n      const enterValidation: EnterValidation = validations.find(\n        (validation: EnterValidation) => validation.on === 'enter',\n      );\n      if (enterValidation) {\n        const expectedValidations: string[] = enterValidation.validations;\n        expectedValidations.forEach(async (expectedValidation: string) => {\n          const foundValidation = validations.find(validation => validation.name === expectedValidation);\n          if (!foundValidation) {\n            console.error(\n              `Validation ${expectedValidation} not found. Check validations prop to make sure you've included it.`,\n            );\n            return;\n          }\n          if (foundValidation.on === 'focus') {\n            await this.onFocus();\n          }\n          if (foundValidation.on === 'change') {\n            const { value } = this.state;\n            await this.onChange(value);\n          }\n          if (foundValidation.on === 'blur') {\n            await this.onBlur();\n          }\n          const { value, valid } = this.state;\n          if (valid && typeof enterCallback !== 'undefined') {\n            enterCallback();\n          }\n        });\n      }\n      return;\n    }\n    const { valid } = this.state;\n    if (valid && typeof enterCallback !== 'undefined') {\n      enterCallback();\n    }\n  };\n\n  render() {\n    const { children, type } = this.props;\n    const { value, error, valid } = this.state;\n    return children({\n      value,\n      type,\n      onChange: this.onChange,\n      onBlur: this.onBlur,\n      onFocus: this.onFocus,\n      onEnter: this.onEnter,\n      error: error,\n      valid,\n    });\n  }\n}\n\n// @ts-ignore\nField.__type = FIELD_TYPE_KEY;\n\nexport default Field;\n","import * as React from 'react';\n\nimport { OnboardingService, Tree } from '../../core/services/core.service';\nimport { END_TYPE_KEY } from '../../core/constants';\n\ntype Props = {\n  children: Function;\n};\ntype State = {\n  tree: Tree;\n};\n\nclass End extends React.Component<Props, State> {\n  state = {\n    tree: { ...OnboardingService.tree },\n  };\n\n  render() {\n    const children: Function = this.props.children;\n    return children(this.state.tree);\n  }\n}\n\n// @ts-ignore\nEnd.__type = END_TYPE_KEY;\n\nexport default End;\n"],"names":["const","onboardingService","tree","setStep","step","field","value","OnboardingService","STEP_TYPE_KEY","FIELD_TYPE_KEY","END_TYPE_KEY","React","Onboarding","constructor","props","this","state","numberOfSteps","setState","prevState","Object","currentStep","finished","encounteredStep","stepFound","processedSteps","map","child","type","__type","includes","name","Error","key","__enhancements","nextStep","prevStep","finish","finishForm","initialStep","Children","children","leaf","length","shouldComponentUpdate","nextProps","nextState","render","Provider","onboarding","onboardingRenderer","snakeCase","replace","Step","isValid","validStep","processed","stepContents","enhancements","stepName","setValidStep","setProcessed","snaked_name","conversational","componentDidMount","some","validations","stepRenderer","Field","Promise","resolve","valid","error","setFieldValue","onChangeValidations","filter","validation","on","alreadyErrored","i","validationOk","validator","errorMessage","onFocusValidations","onBlurValidations","enterCallback","enterValidation","find","forEach","expectedValidation","_this","foundValidation","onBlur","onChange","console","onFocus","setField","getFieldValue","checkForDuplicatedEnterValidation","warn","onEnter","End"],"mappings":"mNA2CAA,IAAMC,EA/BN,eACQC,EAAO,YACJC,EAAQC,GACXF,EAAKE,KACTF,EAAKE,GAAQ,UAkBR,MACLF,UACAC,oBAlBgBE,EAAOD,QACG,IAAfF,EAAKE,IACdD,EAAQC,GAGNF,EAAKE,GAAMC,KACfH,EAAKE,GAAMC,GAAS,4BAECA,EAAOD,EAAME,QACR,IAAfJ,EAAKE,SAAsD,IAAtBF,EAAKE,GAAMC,KAC3DH,EAAKE,GAAMC,GAASC,2BAECD,EAAOD,eACF,IAAfF,EAAKE,SAAsD,IAAtBF,EAAKE,GAAMC,GAA+B,GACnFH,EAAKE,GAAMC,KAWIE,GC3CbC,EAAwB,OACxBC,EAAyB,QACzBC,EAAuB,QCKLC,gBAAoB,8BAa7CC,cAEJC,WAAYC,0BACJA,4BAUkBC,EAAKC,kBAEX,GAAKD,EAAKE,iBACvBC,kBAASC,UAAcC,iBACvBD,GACHE,YAAaF,EAAUE,YAAc,gCAKfN,EAAKC,kBAEX,EAAI,KACjBE,kBAASC,UAAcC,iBACvBD,GACHE,YAAaF,EAAUE,YAAc,oCAKlCH,SAAS,CAAEI,UAAU,8CAUQP,EAAKC,mCACnCO,EAAkB,EAClBC,GAAY,EACZC,EAAiB,UACJd,WAAee,IALXX,EAAKD,wBAKqBa,MAIxCA,OACCC,EAAOD,EAAMC,KAAKC,WAInBP,IAAaM,EAAM,OAAOD,KAC1BL,GAAYM,IAASlB,OACrBY,GAAYM,IAASlB,GAAgBkB,IAASpB,EAAe,OAAOmB,MACpEL,GAAYM,IAASpB,EAAe,IAEnCiB,EAAeK,SAASH,EAAMb,MAAMiB,YAChC,IAAIC,6CAA6CL,EAAMb,qDAE/DW,EAAiBA,UAAoBE,EAAMb,MAAMiB,OAC7CR,IAAoBF,GAAgBG,OAQxCD,GAAoC,IAPlCC,GAAY,GCpCMpB,EDqCCuB,GCpCTC,KAAKC,SACVrB,EAAsBJ,EAC5BgB,iBACFhB,GACH6B,IAAK7B,EAAKU,MAAMiB,KAChBjB,MAAOM,iBACFhB,EAAKU,OACRoB,eD6B8B,CACxBC,SAAUpB,EAAKoB,SACfC,SAAUrB,EAAKqB,SACfC,OAAQtB,EAAKuB,qBCxCGlC,MD8ClBkB,GAAYM,IAASlB,SACrBY,GAAYM,IAASlB,EAAqBiB,mBAzE3CX,MAAQ,CACXuB,YAAazB,EAAMyB,aAAe,EAClClB,YAAaP,EAAMyB,aAAe,EAClCjB,UAAU,QAEPL,cCQAuB,WAASd,IDR8BZ,EAAM2B,kBCQ1BC,MACpBA,EAAKd,KAAKC,SAAWrB,EAAe,OAAOkC,IAE9CC,uGDgBHC,+BAAsBC,EAAkBC,SACJ/B,KAAKC,6BAChB8B,EAAUzB,0BAA4ByB,EAAUxB,sBA4CzEyB,yBAGIpC,gBAACqC,GACC1C,MAAO,CACLW,cAAeF,KAAKE,cACpBI,YALkBN,KAAKC,kBAKI,EAC3BiC,WAAY1C,EAAkBL,KAC9BkC,SAAUrB,KAAKqB,SACfD,SAAUpB,KAAKoB,SACfE,OAAQtB,KAAKuB,aAGdvB,KAAKmC,0BA/FWvC,sBEpBTwC,EAAU7C,UACjBA,EAAM8C,QAAQ,MAAO,KCgB9B,IAAMC,cAEJxC,WAAYC,0BACJA,8BAiBQwC,UAA2BvC,EAAKG,SAAS,CAAEqC,UAAWD,gCACtDE,UAA6BzC,EAAKG,SAAS,WAAEsC,wCAyBvDzC,EAAKD,oCACwBC,EAAKC,oBAOhCyC,GAAehB,cAAS,CAC5BN,SAAUqB,+BAA6B,MACvCpB,uCAAsC,MACtCC,OAAQmB,6BAA2B,MACnCD,+BAGKnC,iBACFqC,GACH3C,MAAO,CACL2B,SAAU9B,WAAee,IAAI+B,EAAa3C,MAAM2B,kBAAWd,OFXtCtB,EAAoBqD,KEYlC/B,SACQA,EAAMC,KAAKC,SACXpB,GFdMJ,EEeGsB,EFfiB+B,EEeV,CACzBtD,KAAM+C,EAAUQ,GAChBC,aAAc7C,EAAK6C,aACnBC,aAAc9C,EAAK8C,cFjBlBxD,EAAMuB,KAAKC,SACXpB,EAAuBJ,EAC7Be,iBACFf,GACH4B,IAAK5B,EAAMS,MAAMiB,KACjBjB,MAAOM,iBACFf,EAAMS,OACToB,eAAgBwB,OEaL/B,YAtEPmC,EAAcX,EAAUrC,EAAMiB,MAE/BjB,EAAMiD,gBACTxD,EAAkBJ,QAAQ2D,QAUvB9C,MAAQ,CAAEuC,WAAW,EAAMC,YADA1C,EAAMiD,gHAOxCC,6BAYMjD,KAAKD,MAAM2B,SAAS,CAAEN,sBAAoBC,sBAAoBC,oBAAkBkB,WAAW,mBACtDU,cAAMtC,UAAuBA,EAAMb,MAAMoD,oBAE7EhD,SAAS,CAAEsC,WAAW,iBA0C7BT,yBACShC,KAAKoD,mBAjFGxD,aAsFnB0C,EAAKxB,OAASrB,ECvDd,IAAM4D,cAGJvD,WAAYC,0BACJA,0BA4BIR,UACH,IAAI+D,iBAAQC,KAEZpD,2BACMqD,OAAO,EAAMC,MAAO,wBAKvBzD,EAAKD,kCAETP,EAAkBkE,cAAc1D,EAAK+C,YAAa/C,EAAKX,KAAME,KACxDY,SAAS,CAAEZ,MAAOA,UACMS,EAAKD,oCAAZ,IAEK,IAAvBoD,EAAYvB,OAAc,KACtB+B,EAAsBR,EAAYS,gBAAOC,SAAgC,WAAlBA,EAAWC,QACpEH,UAOEI,GAAiB,EACZC,EAAI,EAAGA,EAAIL,EAAoB/B,SAAWmC,EAAgBC,IAAK,OAGlEhE,EAAKD,kCACHkE,EAAeN,EAAoBK,GAAGE,UAAU3E,GACjD0E,MACE9D,SAAS,CAAEqD,OAAO,EAAOC,MAAOE,EAAoBK,GAAGG,eAE5DJ,GAAiB,GAEnBlB,EAAaoB,GACbV,KAINT,GAAa,GACbS,wCAOC,IAAID,iBAAQC,KAEZpD,2BACMqD,OAAO,EAAMC,MAAO,wBAETzD,EAAKC,cACMD,EAAKD,oCAAZ,IAEK,IAAvBoD,EAAYvB,OAAc,KACtBwC,EAAqBjB,EAAYS,gBAAOC,SAAgC,UAAlBA,EAAWC,QACnEM,UAOEL,GAAiB,EACZC,EAAI,EAAGA,EAAII,EAAmBxC,SAAWmC,EAAgBC,IAAK,OAGjEhE,EAAKD,kCACHkE,EAAeG,EAAmBJ,GAAGE,UAAU3E,GAChD0E,MACE9D,SAAS,CAAEqD,OAAO,EAAOC,MAAOW,EAAmBJ,GAAGG,eAE3DJ,GAAiB,GAEnBlB,EAAaoB,GACbV,KAINA,uCAOC,IAAID,iBAAQC,KAEZpD,2BACMqD,OAAO,EAAMC,MAAO,wBAETzD,EAAKC,cACMD,EAAKD,oCAAZ,IAEK,IAAvBoD,EAAYvB,OAAc,KACtByC,EAAoBlB,EAAYS,gBAAOC,SAAgC,SAAlBA,EAAWC,QAClEO,UAOEN,GAAiB,EACZC,EAAI,EAAGA,EAAIK,EAAkBzC,SAAWmC,EAAgBC,IAAK,OAGhEhE,EAAKD,kCACHkE,EAAeI,EAAkBL,GAAGE,UAAU3E,GAC/C0E,MACE9D,SAAS,CAAEqD,OAAO,EAAOC,MAAOY,EAAkBL,GAAGG,eAE1DJ,GAAiB,GAEnBlB,EAAaoB,GACbV,KAINA,+BAMGe,SAiBKtE,IAhBeA,EAAKD,oCAAZ,IACK,IAAvBoD,EAAYvB,OAgCE5B,EAAKC,kBACe,IAAlBqE,GAClBA,aAjCMC,EAAmCpB,EAAYqB,cAClDX,SAAkD,UAAlBA,EAAWC,KAE1CS,GACoCA,EAAgBpB,YAClCsB,iBAAeC,8CAkBRC,EAAK1E,kBACQ,IAAlBqE,GAClBA,wBALyB,SAAvBM,EAAgBd,0BACZa,EAAKE,mFALc,WAAvBD,EAAgBd,0BAEZa,EAAKG,SADOH,EAAK1E,uEAXnB2E,EAAkBzB,EAAYqB,cAAKX,UAAcA,EAAW7C,OAAS0D,QACtEE,SACHG,QAAQtB,oBACQiB,+GAIS,UAAvBE,EAAgBd,0BACZa,EAAKK,8HAvKfhF,KAAKD,mDAEJgD,YAAcX,EAAUrC,EAAMiB,WAE9B3B,KAAOA,EAEZG,EAAkByF,SAASjF,KAAK+C,YAAa1D,QACxCY,MAAQ,CACXV,MAAOC,EAAkB0F,cAAclF,KAAK+C,YAAa1D,GACzDmE,OAAO,EACPC,MAAO,MAELN,GAAsC,IAAvBA,EAAYvB,QAzBnC,SAA2CuB,UAClCA,EAAYS,gBAAQC,SAAkD,UAAlBA,EAAWC,KAAgBlC,OAAS,EAyBvFuD,CAAkChC,IACpC4B,QAAQK,8DAEJrF,sLA8KViC,wBAC6BhC,KAAKD,QACAC,KAAKC,aAC9ByB,cAAS,2BAGdoD,SAAU9E,KAAK8E,SACfD,OAAQ7E,KAAK6E,OACbG,QAAShF,KAAKgF,QACdK,QAASrF,KAAKqF,QACd5B,kCAjNc7D,aAwNpByD,EAAMvC,OAASpB,EC5Pf,IAAM4F,cAANxF,gDACU,CACNX,KAAMkB,iBAAKb,EAAkBL,uGAG/B6C,yBAESN,EADoB1B,KAAKD,MAAM2B,UACtB1B,KAAKC,MAAMd,UAPbS,aAYlB0F,EAAIxE,OAASnB"}